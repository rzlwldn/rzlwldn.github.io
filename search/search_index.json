{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A Digital Garden of Code, Curiosity, and Continuous Learning","text":"<p>Dive into a curated space where the world of software engineering meets the spirit of lifelong learning. At my garden, you'll find a digital garden blooming with insights on work, exploration, and the endless journey of personal and professional growth.</p>"},{"location":"cheat-sheet/python-install-package/","title":"Installing Packages","text":""},{"location":"cheat-sheet/python-install-package/#requirements-for-installing-packages","title":"Requirements for Installing Packages","text":"<p>This section describes the steps to follow before installing other Python packages.</p>"},{"location":"cheat-sheet/python-install-package/#ensure-you-can-run-python-from-the-command-line","title":"Ensure you can run Python from the command line","text":"<p>Before you go any further, make sure you have Python and that the expected version is available from your command line. You can check this by running:</p> <pre><code>python3 --version\n</code></pre> <p>Note</p> <p>Due to the way most Linux distributions are handling the Python 3 migration, Linux users using the system Python without creating a virtual environment first should replace the <code>python</code> command in this tutorial with <code>python3</code> and the <code>python -m pip</code> command with <code>python3 -m pip --user</code>. Do not run any of the commands in this tutorial with <code>sudo</code>: if you get a permissions error, come back to the section on creating virtual environments, set one up, and then continue with the tutorial as written.</p>"},{"location":"cheat-sheet/python-install-package/#create-a-virtual-environment","title":"Create a virtual environment","text":"<pre><code>python3 -m venv tutorial_env\nsource tutorial_env/bin/activate\n</code></pre> <p>This will create a new virtual environment in the <code>tutorial_env</code> subdirectory, and configure the current shell to use it as the default <code>python</code> environment.</p> <p>Python \u201cVirtual Environments\u201d allow Python packages to be installed in an isolated location for a particular application, rather than being installed globally.</p> <p>Imagine you have an application that needs version 1 of LibFoo, but another application requires version 2. How can you use both these applications? If you install everything into /usr/lib/python3.6/site-packages (or whatever your platform\u2019s standard location is), it\u2019s easy to end up in a situation where you unintentionally upgrade an application that shouldn\u2019t be upgraded.</p> <p>Or more generally, what if you want to install an application and leave it be? If an application works, any change in its libraries or the versions of those libraries can break the application.</p> <p>Also, what if you can\u2019t install packages into the global site-packages directory? For instance, on a shared host.</p> <p>In all these cases, virtual environments can help you. They have their own installation directories and they don\u2019t share libraries with other virtual environments.</p>"},{"location":"cheat-sheet/python-install-package/#use-pip-for-installing","title":"Use pip for Installing","text":"<p>pip is the recommended installer. Below, we\u2019ll cover the most common usage scenarios. For more detail, see the pip docs, which includes a complete Reference Guide.</p> <pre><code>pip install \"SomeProject\"\n</code></pre> <p>To install a specific version:</p> <pre><code>pip install \"SomeProject==1.4\"\n</code></pre> <p>To install a version that\u2019s compatible with a certain version:</p> <pre><code>pip install \"SomeProject~=1.4.2\"\n</code></pre> <p>In this case, this means to install any version \u201c==1.4.*\u201d version that\u2019s also \u201c&gt;=1.4.2\u201d.</p>"},{"location":"cheat-sheet/python-install-package/#upgrading-packages","title":"Upgrading packages","text":"<p>Upgrade an already installed <code>SomeProject</code> to the latest from PyPI.</p> <pre><code>pip install --upgrade SomeProject\n</code></pre>"},{"location":"cheat-sheet/python-install-package/#requirements-files","title":"Requirements files","text":"<p>Install a list of requirements specified in a Requirements File.</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>To write installed package to Requirements file:</p> <pre><code>pip freeze &gt; requirements.txt\n</code></pre>"},{"location":"cheat-sheet/python-packaging/","title":"Installing pip/setuptools/wheel with Linux Package Managers","text":""},{"location":"cheat-sheet/python-packaging/#fedora","title":"Fedora","text":"<pre><code>sudo dnf install python3-pip python3-wheel\n</code></pre> <p>To learn more about Python in Fedora, please visit the official Fedora docs, Python Classroom or Fedora Loves Python.</p>"},{"location":"cheat-sheet/python-packaging/#debianubuntu-and-derivatives","title":"Debian/Ubuntu and derivatives","text":"<p>Firstly, update and refresh repository lists by running this command:</p> <pre><code>sudo apt update\nsudo apt install python3-venv python3-pip\n</code></pre> <p>warning</p> <p>Recent Debian/Ubuntu versions have modified pip to use the \u201cUser Scheme\u201d by default, which is a significant behavior change that can be surprising to some users.</p>"},{"location":"cheat-sheet/python-packaging/#arch-linux","title":"Arch Linux","text":"<pre><code>sudo pacman -S python-pip\n</code></pre>"},{"location":"cheat-sheet/docker/install/","title":"Install Docker Engine on Debian","text":""},{"location":"cheat-sheet/docker/install/#os-requirements","title":"OS requirements","text":"<p>To install Docker Engine, you need the 64-bit version of one of these Debian versions:</p> <pre><code>Debian Bookworm 12 (stable)\nDebian Bullseye 11 (oldstable)\n</code></pre> <p>Docker Engine for Debian is compatible with x86_64 (or amd64), armhf, arm64, and ppc64le (ppc64el) architectures.</p>"},{"location":"cheat-sheet/docker/install/#installation-methods","title":"Installation methods","text":"<p>You can install Docker Engine in different ways, depending on your needs:</p> <ul> <li> <p>Docker Engine comes bundled with Docker Desktop for Linux. This is the easiest and quickest way to get started.</p> </li> <li> <p>Set up and install Docker Engine from Docker's apt repository.</p> </li> <li> <p>Install it manually and manage upgrades manually.</p> </li> <li> <p>Use a convenience script. Only recommended for testing and development environments.</p> </li> </ul>"},{"location":"cheat-sheet/docker/install/#install-using-the-apt-repository","title":"Install using the apt repository","text":"<p>Before you install Docker Engine for the first time on a new host machine, you need to set up the Docker <code>apt</code> repository. Afterward, you can install and update Docker from the repository.</p> <ol> <li>Set up Docker's <code>apt</code> repository.     <pre><code># Add Docker's official GPG key:\nsudo apt-get update\nsudo apt-get install ca-certificates curl\nsudo install -m 0755 -d /etc/apt/keyrings\nsudo curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc\nsudo chmod a+r /etc/apt/keyrings/docker.asc\n\n# Add the repository to Apt sources:\necho \\\n    \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian \\\n    $(. /etc/os-release &amp;&amp; echo \"$VERSION_CODENAME\") stable\" | \\\n    sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\nsudo apt-get update\n</code></pre></li> <li> <p>Install the Docker packages.     To install the latest version, run:</p> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n</code></pre> </li> </ol>"},{"location":"cheat-sheet/docker/install/#linux-post-installation-steps-for-docker-engine","title":"Linux post-installation steps for Docker Engine","text":"<p>These optional post-installation procedures describe how to configure your Linux host machine to work better with Docker.</p>"},{"location":"cheat-sheet/docker/install/#manage-docker-as-a-non-root-user","title":"Manage Docker as a non-root user","text":"<p>The Docker daemon binds to a Unix socket, not a TCP port. By default it's the <code>root</code> user that owns the Unix socket, and other users can only access it using <code>sudo</code>. The Docker daemon always runs as the <code>root</code> user.</p> <p>If you don't want to preface the <code>docker</code> command with <code>sudo</code>, create a Unix group called <code>docker</code> and add users to it. When the Docker daemon starts, it creates a Unix socket accessible by members of the <code>docker</code> group. On some Linux distributions, the system automatically creates this group when installing Docker Engine using a package manager. In that case, there is no need for you to manually create the group.</p> <p>Warning</p> <p>The <code>docker</code> group grants root-level privileges to the user. For details on how this impacts security in your system, see Docker Daemon Attack Surface.</p> <p>To create the <code>docker</code> group and add your user:</p> <ol> <li> <p>Create the <code>docker</code> group.     <pre><code>sudo groupadd docker\n</code></pre></p> </li> <li> <p>Add your user to the docker group.     <pre><code>sudo usermod -aG docker $USER\n</code></pre></p> </li> <li> <p>Log out and log back in so that your group membership is re-evaluated.     You can also run the following command to activate the changes to groups:     <pre><code>newgrp docker\n</code></pre></p> </li> <li> <p>Verify that you can run docker commands without sudo.     <pre><code>docker run hello-world\n</code></pre></p> </li> </ol>"},{"location":"cheat-sheet/docker/install/#configure-docker-to-start-on-boot-with-systemd","title":"Configure Docker to start on boot with systemd","text":"<p>Many modern Linux distributions use systemd to manage which services start when the system boots. On Debian and Ubuntu, the Docker service starts on boot by default. To automatically start Docker and containerd on boot for other Linux distributions using systemd, run the following commands:</p> <pre><code>sudo systemctl enable docker.service\nsudo systemctl enable containerd.service\n</code></pre> <p>To stop this behavior, use disable instead.</p> <pre><code>sudo systemctl disable docker.service\nsudo systemctl disable containerd.service\n</code></pre>"},{"location":"cheat-sheet/docker/portainer/","title":"Install Portainer CE with Docker on Linux","text":""},{"location":"cheat-sheet/docker/portainer/#deployment","title":"Deployment","text":"<p>First, create the volume that Portainer Server will use to store its database:</p> <pre><code>docker volume create portainer_data\n</code></pre> <p>Then, download and install the Portainer Server container:</p> <pre><code>docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:2.21.0\n</code></pre> <p>Notes</p> <p>By default, Portainer generates and uses a self-signed SSL certificate to secure port 9443. Alternatively you can provide your own SSL certificate during installation or via the Portainer UI after installation is complete.</p> <p>If you require HTTP port <code>9000</code> open for legacy reasons, add the following to your <code>docker run</code> command: <code>-p 9000:9000</code></p> <p>Portainer Server has now been installed. You can check to see whether the Portainer Server container has started by running docker ps:</p> <pre><code>docker ps\n</code></pre>"}]}